#!/usr/bin/env python3

import argparse
import configparser
import sys
import os
import subprocess

from pathlib import Path

__global_config_file = Path.home().joinpath(".config/mgrun.conf")

class RunConfig:
    def __init__(
            self,
            kernel_dir: Path,
            busybox_dir: Path
    ) -> None:
        self.kernel_dir = kernel_dir
        self.busybox_dir = busybox_dir

def prompt_yes_no(prompt: str, default: bool = True) -> bool:
    prompt += " [Y/n] " if default else " [y/N] "
    sys.stderr.write(prompt)
    sys.stderr.flush()
    answer = input().strip().lower()
    if answer.startswith("y"):
        return True
    elif answer.startswith("n"):
        return False
    else:
        return default

# Configuration file related utility functions
    
def get_run_config() -> RunConfig:
    config = configparser.ConfigParser()
    if not __global_config_file.exists():
        print(f"Configuration file '~/.config/mgrun.conf' not found.")
        if prompt_yes_no("Do you want to go with the default one?"):
            return RunConfig(
                kernel_dir="/sources/linux",
                busybox_dir="/sources/busybox-1.36.0/"
            )
    else:
        config.read(__global_config_file)
        return RunConfig(
            kernel_dir=config['Paths']['kerneldir'],
            busybox_dir=config['Paths']['busyboxdir']
        )
    
# Kernel related utility functions

def run_subprocess_in_dir(commands: list, working_dir: Path) -> None:
    for cmd in commands:
        try:
            subprocess.run(cmd, cwd=working_dir,  check=True)
        except subprocess.CalledProcessError as e:
            print(f"Error executing command: {cmd}")
            print(f"Error output: {e.output}")
            exit(1)

def enable_lsp_support(run_config: RunConfig) -> None:
    commands = [
        "./scripts/clang-tools/gen_compile_commands.py"
    ]
    print(f"Enabling LSP support in the kernel directory {run_config.kernel_dir}")
    run_subprocess_in_dir(commands, run_config.kernel_dir)
            
def build_k_x64(run_config: RunConfig) -> None:
    commands = [
        "/usr/bin/make CC=clang x86_64_defconfig".split(),
        "/usr/bin/make CC=clang -j8 all".split()
    ]
    print(f"Building the kernel located at {run_config.kernel_dir} with x86_64 config")
    run_subprocess_in_dir(commands, run_config.kernel_dir)

def build_k_i386(run_config: RunConfig) -> None:
    commands = [
        "/usr/bin/make CC=clang i386_defconfig".split(),
        "/usr/bin/make CC=clang -j8 all".split()
    ]
    print(f"Building the kernel located at {run_config.kernel_dir} with i386 config")
    run_subprocess_in_dir(commands, run_config.kernel_dir)

def build_k_arm64(run_config: RunConfig) -> None:
    commands = [
        "/usr/bin/make CC=clang ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf vexpress_defconfig".split(),
        "/usr/bin/make CC=clang ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf -j8 zImage dtbs".split(),
        "/usr/bin/make CC=clang ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf -j8 modules modules_install".split()
    ]
    print(f"Building the kernel located at {run_config.kernel_dir} with arm64 config")
    run_subprocess_in_dir(commands, run_config.kernel_dir)

def build_k(args: argparse.Namespace, run_config: RunConfig) -> None:
    match args.arch:
        case 'x86':
            build_k_i386(run_config)
        case 'x86-64':
            build_k_x64(run_config)
        case 'arm64':
            build_k_arm64(run_config)
        case _:
            print(f'Architecture not supported yet!')
            exit(1)
    if args.lsp_enable:
        enable_lsp_support(run_config)            
    build_fs(args, run_config)

def build_fs_i386(run_config: RunConfig) -> None:
    return 0

def build_fs_x64(run_config: RunConfig) -> None:
    commands = [
        "make CC=clang defconfig".split(),
        "LDFLAGS=\"--static\" make CC=clang -j4 install".split(),
        "/usr/bin/mkdir -p /staging/initramfs/fs".split(),
        "mkdir -pv bin sbin etc proc sys usr/bin usr/sbin".split(),
        "cp -av /sources/".join(run_config.busybox_dir).join("/_install/* .").split(),
        "cp /scripts/init .".split(),
        "find . -print0 | cpio --null -ov --format=newc | gzip -9 > /staging/initramfs-busybox-x86.cpio.gz".split(),
    ]
    run_subprocess_in_dir(commands, run_config.busybox_dir)
    
def build_fs(args: argparse.Namespace, run_config: RunConfig) -> None:
    match args.arch:
        case 'x86':
            build_fs_i386(run_config)
        case 'x86_64':
            build_fs_x64(run_config)
        case 'arm64':
            build_fs_arm64(run_config)

def run_k_arm64(run_config: RunConfig, with_lsp: bool) -> None:
    return 0
def run_k_x64(run_config: RunConfig, with_lsp: bool) -> None:
    commands = [
        "qemu-system-x86_64 -s -smp 4 -kernel /sources/linux/arch/x86_64/boot/bzImage -initrd /staging/initramfs-busybox-x86.cpio.gz -append \"console=ttyS0 init=/init\" -vnc :0 -k en-us -nographic".split()
    ]
    run_subprocess_in_dir(commands, run_config.kernel_dir)
    
def run_k_i386(run_config: RunConfig, with_lsp: bool) -> None:
    return 0
            
def run_k(args: argparse.Namespace, run_config: RunConfig) -> None:
    print(args)
    exit(1)
    match args.arch:
        case 'x86':
            run_k_i386(run_config)
        case 'x86_64':
            run_k_x64(run_config)
        case 'arm64':
            run_k_arm64(run_config)        

def check_permissions() -> None:
    if os.geteuid() != 0:
        print(f"You are not running as root, this program requires you to have root privileges. Try again!")
        exit(1)
            
def main() -> None:
    parser = argparse.ArgumentParser(
        prog="run",
        description="`run` is a kernel helper that I use to automate some compilation and running tasks in my day-to-day work with the Linux kernel.")

    parser.add_argument("-v", "--verbose", help="Provide exhaustive output logs from all the tools used internally by `run`", action="store_true")

    subparsers = parser.add_subparsers(
        title="command", description="command to run", dest="command")

    parser_build = subparsers.add_parser(
        "build",
        help="Build the Linux kernel specified in the run configuration file",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser_build.add_argument("arch", help="Target architecture for which we want to build the kernel", choices=["x86-64", "x86", "arm64"], type=str, default="x86-64")
    parser_build.add_argument("-lsp", "--lsp-enable", help="Option on whether to enable LSP support when building the kernel", action="store_true")

    parser_build.set_defaults(func=build_k)

    parser_run = subparsers.add_parser(
        "launch",
        help="Launch the Linux kernel specified in the run configuration file",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser_run.add_argument("-d","--debug", help="Launch QEMU with the `-s` option to allow `gdb` to connect", action="store_true")

    parser_run.set_defaults(func=run_k)

    if len(sys.argv) == 1:
        parser.print_help()
        parser.exit()

    check_permissions()

    args = parser.parse_args()
    args.func(args, get_run_config())

if __name__ == "__main__":
    main()
